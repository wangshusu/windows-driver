## 驱动书本学习笔记

1第1篇 入门篇
第1章 从两个最简单的驱动谈起 2
1.1 DDK的安装 2
1.2 第一个驱动程序HelloDDK的代码分析 3
1.2.1 HelloDDK的头文件 4
1.2.2 HelloDDK的入口函数 5
1.2.3 创建设备例程 6
1.2.4 卸载驱动例程 8
1.2.5 默认派遣例程 9
1.3 HelloDDK的编译和安装 9
1.3.1 用DDK环境编译HelloDDK 9
1.3.2 用VC集成开发环境编译HelloDDK 11
1.3.3 HelloDDK的安装 14
1.4 第二个驱动程序HelloWDM的代码分析 16
1.4.1 HelloWDM的头文件 16
1.4.2 HelloWDM的入口函数 17
1.4.3 HelloWDM的AddDevice例程 18
1.4.4 HelloWDM处理PNP的回调函数 20
1.4.5 HelloWDM对PNP的默认处理 22
1.4.6 HelloWDM对IRP_MN_REMOVE_DEVICE的处理 23
1.4.7 HelloWDM对其他IRP的回调函数 23
1.4.8 HelloWDM的卸载例程 24
1.5 HelloWDM的编译和安装 24
1.5.1 用DDK编译环境编译HelloWDM 24
1.5.2 HelloWDM的编译过程 25
1.5.3 安装HelloWDM 25
1.6 小结 29
第2章 Windows操作驱动的基本概念 31
2.1 Windows操作系统概述 31
2.1.1 Windows家族 31
2.1.2 Windows特性 32
2.1.3 用户模式和内核模式 34
2.1.4 操作系统与应用程序 36
2.2 操作系统分层 37
2.2.1 Windows操作系统总体架构 37
2.2.2 应用程序与Win32子系统 38
2.2.3 其他环境子系统 40
2.2.4 Native API 41
2.2.5 系统服务 41
2.2.6 执行程序组件 42
2.2.7 驱动程序 44
2.2.8 内核 44
2.2.9 硬件抽象层 45
2.2.10 Windows与微内核 45
2.3 从应用程序到驱动程序 46
2.4 小结 48
第3章 Windows驱动编译环境配置、安装及调试 49
3.1 用C语言还是用C++语言 49
3.1.1 调用约定 50
3.1.2 函数的导出名 52
3.1.3 运行时函数的调用 53
3.2 用DDK编译环境编译驱动程序 54
3.2.1 编译版本 55
3.2.2 nmake工具 55
3.2.3 build工具 56
3.2.4 makefile文件 57
3.2.5 dirs文件 58
3.2.6 sources文件 58
3.2.7 makefile.inc文件 59
3.2.8 build工具的环境变量 60
3.2.9 build工具的命令行参数 61
3.3 用VC编译驱动程序 62
3.3.1 建立驱动程序工程 62
3.3.2 修改编译选项 62
3.3.3 修改链接选项 63
3.3.4 其他修改 64
3.3.5 VC编译小结 65
3.4 查看调试信息 66
3.4.1 打印调试语句 66
3.4.2 查看调试语句 67
3.5 手动加载NT式驱动 68
3.6 编写程序加载NT式驱动 68
3.6.1 SCM组件和Windows服务 69
3.6.2 加载NT驱动的代码 71
3.6.3 卸载NT驱动的代码 74
3.6.4 实验 76
3.7 WDM式驱动的加载 78
3.7.1 WDM的手动安装 78
3.7.2 简单的INF文件剖析 79
3.8 WDM设备安装在注册表中的变化 81
3.8.1 硬件子键 81
3.8.2 类子键 83
3.8.3 服务子键 85
3.9 小结 86

##### 第4章 驱动程序的基本结构 87

###### 4.1.1 驱动对象（DRIVER_OBJECT） 87

```C++
typedef struct _DRIVER_OBJECT {
    CSHORT Type;                     // 对象类型，通常是 `IO_TYPE_DRIVER` (0x13)。
    CSHORT Size;                     // 结构的大小（以字节为单位），通常是 sizeof(DRIVER_OBJECT)。
    PVOID DeviceObject;              // 指向驱动程序所属设备对象的指针。
    ULONG Flags;                     // 用于标识驱动程序的各种属性和状态的标志位。
    PVOID DriverStart;               // 驱动程序的入口点函数的地址。
    ULONG DriverSize;                // 驱动程序的大小（以字节为单位）。
    PVOID DriverSection;             // 指向驱动程序映像的节头的指针。
    PDRIVER_EXTENSION DriverExtension; // 指向驱动程序扩展结构的指针。
    UNICODE_STRING DriverName;       // 包含驱动程序名称的 UNICODE 字符串结构。
    PDRIVER_UNLOAD DriverUnload;     // 指向驱动程序卸载函数的指针。
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1]; // 指向驱动程序主要功能处理函数的指针数组。
    // ... 其他成员
} DRIVER_OBJECT, *PDRIVER_OBJECT;

```

- `Type`：表示对象类型的字段，通常为 `IO_TYPE_DRIVER` (0x13)，表示它是一个驱动对象。
- `Size`：表示结构的大小（以字节为单位），通常是 `sizeof(DRIVER_OBJECT)`，用于内核在访问结构时正确解释其大小。
- `DeviceObject`：指向驱动程序所属设备对象的指针。设备对象是驱动程序与设备之间的接口。
- `Flags`：用于标识驱动程序的各种属性和状态的标志位。这些标志位用于控制驱动程序的行为和特性。
- `DriverStart`：指向驱动程序的入口点函数的地址。当驱动程序加载时，系统会从这个地址开始执行。
- `DriverSize`：表示驱动程序的大小（以字节为单位）。这可以帮助操作系统了解驱动程序的尺寸。
- `DriverSection`：指向驱动程序映像的节头的指针。这用于访问驱动程序文件映像的内存结构信息。
- `DriverExtension`：指向驱动程序扩展结构的指针。驱动程序扩展提供额外的驱动信息和功能。
- `DriverName`：包含驱动程序名称的 UNICODE 字符串结构。这是驱动程序的唯一标识。
- `DriverUnload`：指向驱动程序卸载函数的指针。这个函数在驱动程序卸载时被调用，进行清理和释放资源。
- `MajorFunction`：一个指针数组，用于存储处理驱动程序主要功能的函数指针。每个元素对应一个 `IRP_MJ_*` 常数，表示对应主要功能的处理函数。这些函数用于处理 I/O 请求。

![image-20230703230928910](https://bucketforago.oss-cn-shenzhen.aliyuncs.com/typora/202307032309979.png)



###### 4.1.2 设备对象（DEVICE_OBJECT） 89

```C++
typedef struct _DEVICE_OBJECT {
    CSHORT Type;                  // 对象类型，通常是 `IO_TYPE_DEVICE` (0x14)。
    USHORT Size;                  // 结构的大小（以字节为单位），通常是 `sizeof(DEVICE_OBJECT)`。
    LONG ReferenceCount;          // 设备对象的引用计数，用于管理设备对象的生命周期。
    PDRIVER_OBJECT DriverObject;  // 指向管理此设备对象的驱动程序对象的指针。
    PVOID DeviceExtension;        // 设备对象的扩展指针，可以用于驱动程序保存设备特定的信息。
    ULONG Characteristics;        // 设备对象的特性标志，用于描述设备的属性和功能。
    DEVICE_TYPE DeviceType;       // 设备的类型，用于标识设备的类别。
    CCHAR StackSize;              // 设备对象堆栈的大小。
    union {
        LIST_ENTRY ListEntry;     // 设备对象的队列信息，可以用于排队待处理的请求。
        WAIT_CONTEXT_BLOCK Wcb;   // 或者是等待上下文块（Wait Context Block）。
    } Queue;
    ULONG AlignmentRequirement;   // 设备对象的对齐要求，指定了设备数据的对齐方式。
    KDEVICE_QUEUE DeviceQueue;    // 设备队列，用于管理设备对象上的请求队列。
    KDPC Dpc;                     // 用于设备对象的延迟过程调用（DPC）。
    ULONG ActiveThreadCount;      // 活动线程计数，用于跟踪设备对象当前活动的线程数。
    PSECURITY_DESCRIPTOR SecurityDescriptor; // 设备对象的安全描述符，用于控制对设备对象的访问权限。
    KEVENT DeviceLock;            // 设备对象的锁，用于同步对设备对象的访问。
    USHORT SectorSize;            // 设备扇区大小，用于描述设备的扇区尺寸。
    USHORT Spare1;                // 备用字段。
    struct _DEVOBJ_EXTENSION* DeviceObjectExtension; // 设备对象的扩展结构。
    PVOID Reserved;               // 保留字段。
} DEVICE_OBJECT, *PDEVICE_OBJECT;

```

- `Type`：指示对象类型的字段，通常为 `IO_TYPE_DEVICE` (0x14)。
- `Size`：结构的大小（以字节为单位），通常是 `sizeof(DEVICE_OBJECT)`。
- `ReferenceCount`：设备对象的引用计数，用于管理设备对象的生命周期。
- `DriverObject`：指向管理此设备对象的驱动程序对象的指针。
- `DeviceExtension`：设备对象的扩展指针，可以用于驱动程序保存设备特定的信息。
- `Characteristics`：设备对象的特性标志，用于描述设备的属性和功能。
- `DeviceType`：设备的类型，用于标识设备的类别。
- `StackSize`：设备对象堆栈的大小。
- `Queue`：设备对象的队列信息，可以用于排队待处理的请求。
- `AlignmentRequirement`：设备对象的对齐要求，指定了设备数据的对齐方式。
- `DeviceQueue`：设备队列，用于管理设备对象上的请求队列。
- `Dpc`：用于设备对象的延迟过程调用（DPC）。
- `ActiveThreadCount`：活动线程计数，用于跟踪设备对象当前活动的线程数。
- `SecurityDescriptor`：设备对象的安全描述符，用于控制对设备对象的访问权限。
- `DeviceLock`：设备对象的锁，用于同步对设备对象的访问。
- `SectorSize`：设备扇区大小，用于描述设备的扇区尺寸。
- `Spare1`：备用字段。
- `DeviceObjectExtension`：设备对象的扩展结构。
- `Reserved`：保留字段。

![image-20230703232348487](https://bucketforago.oss-cn-shenzhen.aliyuncs.com/typora/202307032323604.png)

![image-20230703232404170](https://bucketforago.oss-cn-shenzhen.aliyuncs.com/typora/202307032324253.png)



4.1.3 设备扩展 91

![image-20230703232456245](https://bucketforago.oss-cn-shenzhen.aliyuncs.com/typora/202307032324294.png)

![image-20230703232447635](https://bucketforago.oss-cn-shenzhen.aliyuncs.com/typora/202307032324701.png)

4.2 NT式驱动的基本结构 92

![image-20230703233207410](https://bucketforago.oss-cn-shenzhen.aliyuncs.com/typora/202307032332547.png)



![image-20230703233609148](https://bucketforago.oss-cn-shenzhen.aliyuncs.com/typora/202307032336188.png)

自己的函数



4.2.1 驱动加载过程与驱动入口函数（DriverEntry） 92

###### 4.2.2 创建设备对象 95

```C++
NTSTATUS IoCreateDevice(
  _In_     PDRIVER_OBJECT       DriverObject,
  _In_     ULONG                DeviceExtensionSize,
  _In_opt_ PUNICODE_STRING      DeviceName,
  _In_     DEVICE_TYPE          DeviceType,
  _In_     ULONG                DeviceCharacteristics,
  _In_     BOOLEAN              Exclusive,
  _Out_    PDEVICE_OBJECT*      DeviceObject
);

```

- `DriverObject`：指向驱动程序对象的指针。驱动程序通过将设备对象与其关联，来管理和控制设备。
- `DeviceExtensionSize`：设备对象的扩展结构的大小，以字节为单位。驱动程序可以通过设备对象的扩展来存储和访问设备特定的数据。
- `DeviceName`：可选参数，指向设备名称的 `UNICODE_STRING` 结构指针。这是设备对象的唯一标识符。
- `DeviceType`：设备的类型，用于标识设备的类别。例如，文件系统驱动程序可以使用 `FILE_DEVICE_DISK_FILE_SYSTEM`。
- `DeviceCharacteristics`：设备对象的特性标志，用于描述设备的属性和功能。
- `Exclusive`：指定是否以独占方式创建设备对象。若为 `TRUE`，则只有一个进程能够打开设备对象。
- `DeviceObject`：输出参数，指向创建的设备对象的指针。

函数返回值为 `NTSTATUS` 类型，表示函数执行的结果状态。

`IoCreateDevice` 函数的作用是在驱动程序中创建一个设备对象，并将其与驱动程序关联。创建设备对象后，驱动程序可以通过设备对象执行以下操作：

- 注册设备所支持的 I/O 请求处理函数（Major Function）。
- 设置设备特性和属性。
- 分配和释放设备所需的资源。
- 进行设备与驱动程序之间的通信。



###### 4.2.3 DriverUnload例程 97

4.2.4 用WinObj观察驱动对象和设备对象 98
4.2.5 用DeviceTree观察驱动对象和设备对象 101
4.3 WDM式驱动的基本结构 102
4.3.1 物理设备对象与功能设备对象 102
4.3.2 WDM驱动的入口程序 104
4.3.3 WDM驱动的AddDevice例程 105
4.3.4 DriverUnload例程 107
4.3.5 对IRP_MN_REMOVE_DEVICE IRP的处理 108
4.3.6 用Device Tree查看WDM设备对象栈 109
4.4 设备的层次结构 110
4.4.1 驱动程序的垂直层次结构 111
4.4.2 驱动程序的水平层次结构 112
4.4.3 驱动程序的复杂层次结构 112
4.5 实验 114
4.5.1 改写HelloDDK查看驱动结构 114
4.5.2 改写HelloWDM查看驱动结构 116
4.6 小结 117
第5章 Windows内存管理 118
5.1 内存管理概念 118
5.1.1 物理内存概念（Physical Memory Address） 118
5.1.2 虚拟内存地址概念（Virtual Memory Address） 119
5.1.3 用户模式地址和内核模式地址 120
5.1.4 Windows驱动程序和进程的关系 121
5.1.5 分页与非分页内存 122
5.1.6 分配内核内存 123
5.2 在驱动中使用链表 124
5.2.1 链表结构 124
5.2.2 链表初始化 125
5.2.3 从首部插入链表 126
5.2.4 从尾部插入链表 126
5.2.5 从链表删除 127
5.2.6 实验 129
5.3 Lookaside结构 130
5.3.1 频繁申请内存的弊端 130
5.3.2 使用Lookaside 130
5.3.3 实验 132
5.4 运行时函数 133
5.4.1 内存间复制（非重叠） 133
5.4.2 内存间复制（可重叠） 134
5.4.3 填充内存 134
5.4.4 内存比较 135
5.4.5 关于运行时函数使用的注意事项 135
5.4.6 实验 137
5.5 使用C++特性分配内存 137
5.6 其他 139
5.6.1 数据类型 139
5.6.2 返回状态值 140
5.6.3 检查内存可用性 142
5.6.4 结构化异常处理（try-except块） 142
5.6.5 结构化异常处理（try-finally块） 144
5.6.6 使用宏需要注意的地方 146
5.6.7 断言 147
5.7 小结 147
第6章 Windows内核函数 148
6.1 内核模式下的字符串操作 148
6.1.1 ASCII字符串和宽字符串 148
6.1.2 ANSI_STRING字符串与UNICODE_STRING字符串 149
6.1.3 字符初始化与销毁 151
6.1.4 字符串复制 152
6.1.5 字符串比较 153
6.1.6 字符串转化成大写 154
6.1.7 字符串与整型数字相互转换 155
6.1.8 ANSI_STRING字符串与UNICODE_STRING字符串相互转换 157
6.2 内核模式下的文件操作 158
6.2.1 文件的创建 158
6.2.2 文件的打开 161
6.2.3 获取或修改文件属性 163
6.2.4 文件的写操作 166
6.2.5 文件的读操作 167
6.3 内核模式下的注册表操作 169
6.3.1 创建关闭注册表 170
6.3.2 打开注册表 172
6.3.3 添加、修改注册表键值 173
6.3.4 查询注册表 175
6.3.5 枚举子项 178
6.3.6 枚举子键 180
6.3.7 删除子项 182
6.3.8 其他 183
6.4 小结 185
第7章 派遣函数 186
7.1 IRP与派遣函数 186
7.1.1 IRP 186
7.1.2 IRP类型 188
7.1.3 对派遣函数的简单处理 188
7.1.4 通过设备链接打开设备 190
7.1.5 编写一个更通用的派遣函数 191
7.1.6 跟踪IRP的利器IRPTrace 193
7.2 缓冲区方式读写操作 196
7.2.1 缓冲区设备 196
7.2.2 缓冲区设备读写 197
7.2.3 缓冲区设备模拟文件读写 200
7.3 直接方式读写操作 203
7.3.1 直接读取设备 204
7.3.2 直接读取设备的读写 205
7.4 其他方式读写操作 207
7.4.1 其他方式设备 207
7.4.2 其他方式读写 208
7.5 IO设备控制操作 209
7.5.1 DeviceIoControl与驱动交互 209
7.5.2 缓冲内存模式IOCTL 210
7.5.3 直接内存模式IOCTL 212
7.5.4 其他内存模式IOCTL 214
7.6 小结 216
第2篇 进阶篇
第8章 驱动程序的同步处理 218
8.1 基本概念 218
8.1.1 问题的引出 218
8.1.2 同步与异步 219
8.2 中断请求级 219
8.2.1 中断请求（IRQ）与可编程中断控制器（PIC） 220
8.2.2 高级可编程控制器（APIC） 221
8.2.3 中断请求级（IRQL） 221
8.2.4 线程调度与线程优先级 222
8.2.5 IRQL的变化 223
8.2.6 IRQL与内存分页 223
8.2.7 控制IRQL提升与降低 224
8.3 自旋锁 224
8.3.1 原理 224
8.3.2 使用方法 225
8.4 用户模式下的同步对象 225
8.4.1 用户模式的等待 226
8.4.2 用户模式开启多线程 226
8.4.3 用户模式的事件 227
8.4.4 用户模式的信号灯 229
8.4.5 用户模式的互斥体 230
8.4.6 等待线程完成 232
8.5 内核模式下的同步对象 232
8.5.1 内核模式下的等待 232
8.5.2 内核模式下开启多线程 234
8.5.3 内核模式下的事件对象 236
8.5.4 驱动程序与应用程序交互事件对象 237
8.5.5 驱动程序与驱动程序交互事件对象 239
8.5.6 内核模式下的信号灯 240
8.5.7 内核模式下的互斥体 241
8.5.8 快速互斥体 243
8.6 其他同步方法 244
8.6.1 使用自旋锁进行同步 245
8.6.2 使用互锁操作进行同步 247
8.7 小结 249
第9章 IRP的同步 250
9.1 应用程序对设备的同步异步操作 250
9.1.1 同步操作与异步操作原理 250
9.1.2 同步操作设备 252
9.1.3 异步操作设备（方式一） 253
9.1.4 异步操作设备（方式二） 254
9.2 IRP的同步完成与异步完成 256
9.2.1 IRP的同步完成 256
9.2.2 IRP的异步完成 257
9.2.3 取消IRP 262
9.3 StartIO例程 264
9.3.1 并行执行与串行执行 264
9.3.2 StartIO例程 265
9.3.3 示例 267
9.4 自定义的StartIO 270
9.4.1 多个串行化队列 270
9.4.2 示例 271
9.5 中断服务例程 273
9.5.1 中断操作的必要性 273
9.5.2 中断优先级 274
9.5.3 中断服务例程（ISR） 274
9.6 DPC例程 275
9.6.1 延迟过程调用例程（DPC） 275
9.6.2 DpcForISR 275
9.7 小结 276
第10章 定时器 277
10.1 定时器实现方式一 277
10.1.1 I/O定时器 277
10.1.2 示例代码 278
10.2 定时器实现方式二 280
10.2.1 DPC定时器 280
10.2.2 示例代码 282
10.3 等待 284
10.3.1 第一种方法：使用KeWaitForSingleObject 284
10.3.2 第二种方法：使用KeDelayExecutionThread 285
10.3.3 第三种方法：使用KeStallExecutionProcessor 285
10.3.4 第四种方法：使用定时器 286
10.4 时间相关的其他内核函数 286
10.4.1 时间相关函数 286
10.4.2 示例代码 288
10.5 IRP的超时处理 289
10.5.1 原理 289
10.5.2 示例代码 289
10.6 小结 291
第11章 驱动程序调用驱动程序 292
11.1 以文件句柄形式调用其他驱动程序 292
11.1.1 准备一个标准驱动 292
11.1.2 获得设备句柄 294
11.1.3 同步调用 295
11.1.4 异步调用方法一 297
11.1.5 异步调用方法二 299
11.1.6 通过符号链接打开设备 301
11.2 通过设备指针调用其他驱动程序 303
11.2.1 用IoGetDeviceObjectPointer获得设备指针 304
11.2.2 创建IRP传递给驱动的派遣函数 305
11.2.3 用IoBuildSynchronousFsdRequest创建IRP 306
11.2.4 用IoBuildAsynchronousFsdRequest创建IRP 308
11.2.5 用IoAllocateIrp创建IRP 311
11.3 其他方法获得设备指针 314
11.3.1 用ObReferenceObjectByName获得设备指针 314
11.3.2 剖析IoGetDeviceObjectPointer 317
11.4 小结 318
第12章 分层驱动程序 319
12.1 分层驱动程序概念 319
12.1.1 分层驱动程序的概念 319
12.1.2 设备堆栈与挂载 321
12.1.3 I/O堆栈 322
12.1.4 向下转发IRP 323
12.1.5 挂载设备对象示例 324
12.1.6 转发IRP示例 325
12.1.7 分析 326
12.1.8 遍历设备栈 327
12.2 完成例程 330
12.2.1 完成例程概念 330
12.2.2 传播Pending位 332
12.2.3 完成例程返回STATUS_SUCCESS 333
12.2.4 完成例程返回STATUS_MORE_PROCESSING_REQUIRED 334
12.3 将IRP分解成多个IRP 336
12.3.1 原理 336
12.3.2 准备底层驱动 337
12.3.3 读派遣函数 338
12.3.4 完成例程 341
12.3.5 分析 342
12.4 WDM驱动程序架构 344
12.4.1 WDM与分层驱动程序 344
12.4.2 WDM的加载方式 345
12.4.3 功能设备对象 346
12.4.4 物理设备对象 346
12.4.5 物理设备对象与即插即用 348
12.5 小结 349
第13章 让设备实现即插即用 350
13.1 即插即用概念 350
13.1.1 历史原因 350
13.1.2 即插即用的目标 351
13.1.3 Windows中即插即用相关组件 351
13.1.4 遗留驱动程序 352
13.2 即插即用IRP 352
13.2.1 即插即用IRP的功能代码 353
13.2.2 处理即插即用IRP的派遣函数 353
13.3 通过设备接口寻找设备 356
13.3.1 设备接口 356
13.3.2 WDM驱动中设置接口 357
13.3.3 应用程序寻找接口 359
13.3.4 查看接口设备 360
13.4 启动和停止设备 361
13.4.1 为一个实际硬件安装HelloWDM 362
13.4.2 启动设备 364
13.4.3 转发并等待 366
13.4.4 获得设备相关资源 367
13.4.5 枚举设备资源 368
13.4.6 停止设备 372
13.5 即插即用的状态转换 373
13.5.1 状态转换图 373
13.5.2 IRP_MN_QUERY_STOP_DEVICE 374
13.5.3 IRP_MN_QUERY_REMOVE_DEVICE 374
13.6 其他即插即用IRP 375
13.6.1 IRP_MN_FILTER_RESOURCE_REQUIREMENTS 375
13.6.2 IRP_MN_QUERY_CAPABILITIES 376
13.7 小结 377
第14章 电源管理 378
14.1 WDM电源管理模型 378
14.1.1 概述 378
14.1.2 热插拔 378
14.1.3 电源状态 379
14.1.4 设备状态 379
14.1.5 状态转换 380
14.2 处理IRP_MJ_POWER 381
14.3 处理IRP_MN_QUERY_CAPABILITIES 381
14.3.1 DEVICE_CAPABILITIES 381
14.3.2 一个试验 382
14.4 小结 384
第3篇 实用篇
第15章 I/O端口操作 386
15.1 概述 386
15.1.1 从DOS说起 386
15.1.2 汇编实现 387
15.1.3 DDK实现 389
15.2 工具软件WinIO 390
15.2.1 WinIO简介 390
15.2.2 使用方法 390
15.3 端口操作实现方法一 391
15.3.1 驱动端程序 391
15.3.2 应用程序端程序 393
15.4 端口操作实现方法二 394
15.4.1 驱动端程序 394
15.4.2 应用程序端程序 396
15.5 端口操作实现方法三 397
15.5.1 驱动端程序 397
15.5.2 应用程序端程序 398
15.6 端口操作实现方法四 399
15.6.1 原理 399
15.6.2 驱动端程序 400
15.6.3 应用程序端程序 401
15.7 驱动PC喇叭 402
15.7.1 可编程定时器 402
15.7.2 PC喇叭 403
15.7.3 操作代码 404
15.8 操作并口设备 405
15.8.1 并口设备简介 405
15.8.2 并口寄存器 406
15.8.3 并口设备操作 408
15.9 小结 410
第16章 PCI设备驱动 411
16.1 PCI总线协议 411
16.1.1 PCI总线简介 411
16.1.2 PCI配置空间简介 412
16.2 访问PCI配置空间方法一 414
16.2.1 两个重要寄存器 414
16.2.2 示例 415
16.3 访问PCI配置空间方法二 417
16.3.1 DDK函数读取配置空间 417
16.3.2 示例 418
16.4 访问PCI配置空间方法三 419
16.4.1 通过即插即用IRP获得PCI配置空间 420
16.4.2 示例 420
16.5 访问PCI配置空间方法四 421
16.5.1 创建IRP_MN_READ_CONFIG 422
16.5.2 示例 422
16.6 PCI设备驱动开发示例 423
16.6.1 开发步骤 424
16.6.2 中断操作 424
16.6.3 操作设备物理内存 425
16.6.4 示例 426
16.7 小结 429
第17章 USB设备驱动 430
17.1 USB总线协议 430
17.1.1 USB设备简介 430
17.1.2 USB连接拓扑结构 431
17.1.3 USB通信的流程 433
17.1.4 USB四种传输模式 435
17.2 Windows下的USB驱动 438
17.2.1 观察USB设备的工具 438
17.2.2 USB设备请求 440
17.2.3 设备描述符 440
17.2.4 配置描述符 442
17.2.5 接口描述符 443
17.2.6 端点描述符 443
17.3 USB驱动开发实例 444
17.3.1 功能驱动与物理总线驱动 444
17.3.2 构造USB请求包 445
17.3.3 发送USB请求包 446
17.3.4 USB设备初始化 447
17.3.5 USB设备的插拔 447
17.3.6 USB设备的读写 448
17.4 小结 450
第18章 SDIO设备驱动 451
18.1 SDIO协议 451
18.1.1 SD内存卡概念 451
18.1.2 SDIO卡概念 452
18.1.3 SDIO总线 452
18.1.4 SDIO令牌 453
18.1.5 SDIO令牌格式 455
18.1.6 SDIO的寄存器 456
18.1.7 CMD52命令 458
18.1.8 CMD53命令 459
18.2 SDIO卡驱动开发框架 459
18.2.1 SDIO Host Controller驱动 459
18.2.2 SDIO卡的初始化 460
18.2.3 中断回调函数 461
18.2.4 获得和设置属性 462
18.2.5 CMD52 464
18.2.6 CMD53 465
18.3 SDIO开发实例 467
18.4 小结 467
第19章 虚拟串口设备驱动 469
19.1 串口简介 469
19.2 DDK串口开发框架 470
19.2.1 串口驱动的入口函数 470
19.2.2 应用程序与串口驱动的通信 473
19.2.3 写的实现 475
19.2.4 读的实现 477
19.3 小结 478
第20章 摄像头设备驱动程序 479
20.1 WDM摄像头驱动框架 479
20.1.1 类驱动与小驱动 479
20.1.2 摄像头的类驱动与小驱动 480
20.1.3 编写小驱动程序 480
20.1.4 小驱动的流控制 481
20.2 虚拟摄像头开发实例 482
20.2.1 编译和安装 482
20.2.2 虚拟摄像头入口函数 484
20.2.3 对STREAM_REQUEST_BLOCK的处理函数 485
20.2.4 打开视频流 487
20.2.5 对视频流的读取 488
20.3 小结 489
第4篇 提高篇
第21章 再论IRP 492
21.1 转发IRP 492
21.1.1 直接转发 492
21.1.2 转发并且等待 492
21.1.3 转发并且设置完成例程 494
21.1.4 暂时挂起当前IRP 495
21.1.5 不转发IRP 496
21.2 创建IRP 496
21.2.1 IoBuildDeviceIoControlRequest 497
21.2.2 创建有超时的IOCTL IRP 498
21.2.3 用IoBuildSynchronousFsdRequest创建IRP 499
21.2.4 关于IoBuildAsynchronousFsdRequest 501
21.2.5 关于IoAllocateIrp 502
21.3 小结 505
第22章 过滤驱动程序 506
22.1 文件过滤驱动程序 506
22.1.1 过滤驱动程序概念 506
22.1.2 过滤驱动程序的入口函数 506
22.1.3 U盘过滤驱动程序 509
22.1.4 过滤驱动程序加载方法一 510
22.1.5 过滤驱动程序加载方法二 511
22.1.6 过滤驱动程序的AddDevice例程 512
22.1.7 磁盘命令过滤 513
22.2 NT式过滤驱动程序 516
22.2.1 NT式过滤驱动程序 516
22.2.2 NT过滤驱动的入口函数 517
22.2.3 挂载过滤驱动 517
22.2.4 过滤键盘读操作 518
22.3 小结 520
第23章 高级调试技巧 521
23.1 一般性调试技巧 521
23.1.1 打印调试信息 521
23.1.2 存储dump信息 521
23.1.3 使用WinDbg调试工具 522
23.2 高级内核调试技巧 524
23.2.1 安装VMWare 525
23.2.2 在虚拟机上加载驱动程序 526
23.2.3 VMWare和WinDbg联合调试驱动程序 527
23.3 用IRPTrace调试驱动程序 528
23.4 小结 530