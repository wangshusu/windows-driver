## 驱动书本学习笔记

1.1 ddk的安装    
　　1.2 第一个驱动程序helloddk的代码分析    
　　　1.2.1 helloddk的头文件    
　　　1.2.2 helloddk的入口函数    
　　　1.2.3 创建设备例程    
　　　1.2.4 卸载驱动例程    
　　　1.2.5 默认派遣例程    
　　1.3 helloddk的编译和安装    
　　　1.3.1 用ddk环境编译helloddk    
　　　1.3.2 用vc集成开发环境编译helloddk    
　　　1.3.3 helloddk的安装    
　　1.4 第二个驱动程序hellowdm的代码分析    
　　　1.4.1 hellowdm的头文件    
　　　1.4.2 hellowdm的入口函数    
　　　1.4.3 hellowdm的adddevice例程    
　　　1.4.4 hellowdm处理pnp的回调函数    
　　　1.4.5 hellowdm对pnp的默认处理    
.　　　1.4.6 hellowdm对irp_mn_remove_device的处理    
　　　1.4.7 hellowdm对其他irp的回调函数    
　　　1.4.8 hellowdm的卸载例程    
　　1.5 hellowdm的编译和安装    
　　　1.5.1 用ddk编译环境编译hellowdm    
　　　1.5.2 hellowdm的编译过程    
　　　1.5.3 安装hellowdm    
　　1.6 小结    
　第2章 windows操作驱动的基本概念    
　驱动程序被操作系统加载在内核模式下，它与windows操作系统内核的其他组件进行密切交互。本章主要介绍windows操作系统内核的基本概念，同时还介绍应用程序和驱动程序之间的通信方法。
　　2.1 windows操作系统概述    
　　　2.1.1 windows家族    
　　　2.1.2 windows特性    
　　　2.1.3 用户模式和内核模式    
　　　2.1.4 操作系统与应用程序    
　　2.2 操作系统分层    
　　　2.2.1 windows操作系统总体架构    
　　　2.2.2 应用程序与win32子系统    
　　　2.2.3 其他环境子系统    
　　　2.2.4 native api    
　　　2.2.5 系统服务    
　　　2.2.6 执行程序组件    
　　　2.2.7 驱动程序    
　　　2.2.8 内核    
　　　2.2.9 硬件抽象层    
　　　2.2.10 windows与微内核    
　　2.3 从应用程序到驱动程序    
　　2.4 小结    
　第3章 windows驱动编译环境配置、安装及调试    
　本章将带领读者一步步对驱动程序进行编译、安装和简单的调试工作。这些步骤虽然简单，但往往困惑着初次接触驱动程序的开发者。
　3.1 用c语言还是用c++语言    
　　　3.1.1 调用约定    
　　　3.1.2 函数的导出名    
　　　3.1.3 运行时函数的调用    
　　3.2 用ddk编译环境编译驱动程序    
　　　3.2.1 编译版本    
　　　3.2.2 nmake工具    
　　　3.2.3 build工具    
　　　3.2.4 makefile文件    
　　　3.2.5 dirs文件    
　　　3.2.6 sources文件    
　　　3.2.7 makefile.inc文件    
　　　3.2.8 build工具的环境变量    
　　　3.2.9 build工具的命令行参数    
　　3.3 用vc编译驱动程序    
　　　3.3.1 建立驱动程序工程    
　　　3.3.2 修改编译选项    
　　　3.3.3 修改链接选项    
　　　3.3.4 其他修改    
　　　3.3.5 vc编译小结    
　　3.4 查看调试信息    
　　　3.4.1 打印调试语句    
　　　3.4.2 查看调试语句    
　　3.5 手动加载nt式驱动    
　　3.6 编写程序加载nt式驱动    
　　　3.6.1 scm组件和windows服务    
　　　3.6.2 加载nt驱动的代码    
　　　3.6.3 卸载nt驱动的代码    
　　　3.6.4 实验    
　　3.7 wdm式驱动的加载    
　　　3.7.1 wdm的手动安装    
　　　3.7.2 简单的inf文件剖析    
　　3.8 wdm设备安装在注册表中的变化    
　　　3.8.1 硬件子键    
　　　3.8.2 类子键    
　　　3.8.3 服务子键    
　　3.9 小结    
　第4章 驱动程序的基本结构    
　本章首先对windows驱动程序的两个重要数据结构进行介绍，分别是驱动对象和设备对象数据结构。另外还要介绍nt驱动程序和wdm驱动程序的入口函数、卸载例程、各种irp派遣上函数等。
　　4.1 windows驱动程序中重要的数据结构    
　　　4.1.1 驱动对象（driver_object）    
　　　4.1.2 设备对象（device_object）    
　　　4.1.3 设备扩展    
　　4.2 nt式驱动的基本结构    
　　　4.2.1 驱动加载过程与驱动入口函数（driverentry）    
　　　4.2.2 创建设备对象    
　　　4.2.3 driverunload例程    
　　　4.2.4 用winobj观察驱动对象和设备对象    
　　　4.2.5 用devicetree观察驱动对象和设备对象    
　　4.3 wdm式驱动的基本结构    
　　　4.3.1 物理设备对象与功能设备对象    
　　　4.3.2 wdm驱动的入口程序    
　　　4.3.3 wdm驱动的adddevice例程    
　　　4.3.4 driverunload例程    
　　　4.3.5 对irp_mn_remove_device irp的处理    
　　　4.3.6 用device tree查看wdm设备对象栈    
　　4.4 设备的层次结构    
　　　4.4.1 驱动程序的垂直层次结构    
　　　4.4.2 驱动程序的水平层次结构    
　　　4.4.3 驱动程序的复杂层次结构    
　　4.5 实验    
　　　4.5.1 改写helloddk查看驱动结构    
　　　4.5.2 改写hellowdm查看驱动结构    
　　4.6 小结    
　第5章 windows内存管理    
　　本章围绕着驱动程序中的内存操作进行了介绍。在驱动程序开发中，首先要注意分页内存和非分页内存的使用。同时，还需要区分物理内存地址和虚拟内存地址这两个概念。
　　5.1 内存管理概念    
　　　5.1.1 物理内存概念（physical memory address）    
　　　5.1.2 虚拟内存地址概念（virtual memory address）    
　　　5.1.3 用户模式地址和内核模式地址    
　　　5.1.4 windows驱动程序和进程的关系    
　　　5.1.5 分页与非分页内存    
　　　5.1.6 分配内核内存    
　　5.2 在驱动中使用链表    
　　　5.2.1 链表结构    
　　　5.2.2 链表初始化    
　　　5.2.3 从首部插入链表    
　　　5.2.4 从尾部插入链表    
　　　5.2.5 从链表删除    
　　　5.2.6 实验    
　　5.3 lookaside结构    
　　　5.3.1 频繁申请内存的弊端    
　　　5.3.2 使用lookaside    
　　　5.3.3 实验    
　　5.4 运行时函数    
　　　5.4.1 内存间复制（非重叠）    
　　　5.4.2 内存间复制（可重叠）    
　　　5.4.3 填充内存    
　　　5.4.4 内存比较    
　　　5.4.5 关于运行时函数使用的注意事项    
　　　5.4.6 实验    
　　5.5 使用c++特性分配内存    
　　5.6 其他    
　　　5.6.1 数据类型    
　　　5.6.2 返回状态值    
　　　5.6.3 检查内存可用性    
　　　5.6.4 结构化异常处理（try-except块）    
　　　5.6.5 结构化异常处理（try-finally块）    
　　　5.6.6 使用宏需要注意的地方    
　　　5.6.7 断言    
　　5.7 小结    
第6章 windows内核函数    
　本章介绍了windows内核模式下的一些常用内核函数，这些函数在驱动程序的开发中将会经常用到。
　　6.1 内核模式下的字符串操作    
　　　6.1.1 ascii字符串和宽字符串    
　　　6.1.2 ansi_string字符串与unicode_string字符串    
　　　6.1.3 字符初始化与销毁    
　　　6.1.4 字符串复制    
　　　6.1.5 字符串比较    
　　　6.1.6 字符串转化成大写    
　　　6.1.7 字符串与整型数字相互转换    
　　　6.1.8 ansi_string字符串与unicode_string字符串相互转换    
　　6.2 内核模式下的文件操作    
　　　6.2.1 文件的创建    
　　　6.2.2 文件的打开    
　　　6.2.3 获取或修改文件属性    
　　　6.2.4 文件的写操作    
　　　6.2.5 文件的读操作    
　　6.3 内核模式下的注册表操作    
　　　6.3.1 创建关闭注册表    
　　　6.3.2 打开注册表    
　　　6.3.3 添加、修改注册表键值    
　　　6.3.4 查询注册表    
　　　6.3.5 枚举子项    
　　　6.3.6 枚举子键    
　　　6.3.7 删除子项    
　　　6.3.8 其他    
　　6.4 小结    
　第7章 派遣函数    
　　本章重点介绍了驱动程序中的处理irp请求的派遣函数。所有对设备的操作最终将转化为irp请求，这些irp请求会被传送到派遣函数处理。
　　7.1 irp与派遣函数    
　　　7.1.1 irp    
　　　7.1.2 irp类型    
　　　7.1.3 对派遣函数的简单处理    
　　　7.1.4 通过设备链接打开设备    
　　　7.1.5 编写一个更通用的派遣函数    
　　　7.1.6 跟踪irp的利器irptrace    
　　7.2 缓冲区方式读写操作    
　　　7.2.1 缓冲区设备    
　　　7.2.2 缓冲区设备读写    
　　　7.2.3 缓冲区设备模拟文件读写    
　　7.3 直接方式读写操作    
　　　7.3.1 直接读取设备    
　　　7.3.2 直接读取设备的读写    
　　7.4 其他方式读写操作    
　　　7.4.1 其他方式设备    
　　　7.4.2 其他方式读写    
　　7.5 io设备控制操作    
　　　7.5.1 deviceiocontrol与驱动交互    
　　　7.5.2 缓冲内存模式ioctl    
　　　7.5.3 直接内存模式ioctl    
　　　7.5.4 其他内存模式ioctl    
　　7.6 小结    
第2篇 进阶篇
　第8章 驱动程序的同步处理    
　本章介绍了驱动程序中常用的同步处理办法，并且将内核模式下的同步处理方法和用户模式下的同步处理方法做了比较。另外，本章还介绍了中断请求级、自旋锁等同步处理机制。
　　8.1 基本概念    
　　　8.1.1 问题的引出    
　　　8.1.2 同步与异步    
　　8.2 中断请求级    
　　　8.2.1 中断请求（irq）与可编程中断控制器（pic）    
　　　8.2.2 高级可编程控制器（apic）    
　　　8.2.3 中断请求级（irql）    
　　　8.2.4 线程调度与线程优先级    
　　　8.2.5 irql的变化    
　　　8.2.6 irql与内存分页    
　　　8.2.7 控制irql提升与降低    
　　8.3 自旋锁    
　　　8.3.1 原理    
　　　8.3.2 使用方法    
　　8.4 用户模式下的同步对象    
　　　8.4.1 用户模式的等待    
　　　8.4.2 用户模式开启多线程    
　　　8.4.3 用户模式的事件    
　　　8.4.4 用户模式的信号灯    
　　　8.4.5 用户模式的互斥体    
　　　8.4.6 等待线程完成    
　　8.5 内核模式下的同步对象    
　　　8.5.1 内核模式下的等待    
　　　8.5.2 内核模式下开启多线程    
　　　8.5.3 内核模式下的事件对象    
　　　8.5.4 驱动程序与应用程序交互事件对象    
　　　8.5.5 驱动程序与驱动程序交互事件对象    
　　　8.5.6 内核模式下的信号灯    
　　　8.5.7 内核模式下的互斥体    
　　　8.5.8 快速互斥体    
　　8.6 其他同步方法    
　　　8.6.1 使用自旋锁进行同步    
　　　8.6.2 使用互锁操作进行同步    
　　　8.7 小结    
　第9章 irp的同步    
　本章详细地介绍了irp的同步处理方法和异步处理方法。另外，本章还介绍了startio例程、中断服务例程、dpc服务例程。
　　9.1 应用程序对设备的同步异步操作    
　　　9.1.1 同步操作与异步操作原理    
　　　9.1.2 同步操作设备    
　　　9.1.3 异步操作设备（方式一）    
　　　9.1.4 异步操作设备（方式二）    
　　9.2 irp的同步完成与异步完成    
　　　9.2.1 irp的同步完成    
　　　9.2.2 irp的异步完成    
　　　9.2.3 取消irp    
　　9.3 startio例程    
　　　9.3.1 并行执行与串行执行    
　　　9.3.2 startio例程    
　　　9.3.3 示例    
　　9.4 自定义的startio    
　　　9.4.1 多个串行化队列    
　　　9.4.2 示例    
　　9.5 中断服务例程    
　　　9.5.1 中断操作的必要性    
　　　9.5.2 中断优先级    
　　　9.5.3 中断服务例程（isr）    
　　9.6 dpc例程    
　　　9.6.1 延迟过程调用例程（dpc）    
　　　9.6.2 dpcforisr    
　　9.7 小结    
　第10章 定时器    
　本章总结了在内核模式下的四种等待方法，读者可以利用这些方法灵活地用在自己的驱动程序中。最后本章还介绍了如何对irp的超时情况进行处理。
　　10.1 定时器实现方式一    
　　　10.1.1 i/o定时器    
　　　10.1.2 示例代码    
　　10.2 定时器实现方式二    
　　　10.2.1 dpc定时器    
　　　10.2.2 示例代码    
　　10.3 等待    
　　　10.3.1 第一种方法：使用kewaitforsingleobject    
　　　10.3.2 第二种方法：使用kedelayexecutionthread    
　　　10.3.3 第三种方法：使用kestallexecutionprocessor    
　　　10.3.4 第四种方法：使用定时器    
　　10.4 时间相关的其他内核函数    
　　　10.4.1 时间相关函数    
　　　10.4.2 示例代码    
　　10.5 irp的超时处理    
　　　10.5.1 原理    
　　　10.5.2 示例代码    
　　10.6 小结    
　第11章 驱动程序调用驱动程序    
本章主要介绍了如何在驱动程序中调用其他驱动程序。比较简单的方法是将被调用的驱动程序以文件的方式操作。比较高级的方法是构造各种irp，并将这些irp传送到被调用的驱动程序中。
　　11.1 以文件句柄形式调用其他驱动程序    
　　　11.1.1 准备一个标准驱动    
　　　11.1.2 获得设备句柄    
　　　11.1.3 同步调用    
　　　11.1.4 异步调用方法一    
　　　11.1.5 异步调用方法二    
　　　11.1.6 通过符号链接打开设备    
　　11.2 通过设备指针调用其他驱动程序    
　　　11.2.1 用iogetdeviceobjectpointer获得设备指针    
　　　11.2.2 创建irp传递给驱动的派遣函数    
　　　11.2.3 用iobuildsynchronousfsdrequest创建irp    
　　　11.2.4 用iobuildasynchronousfsdrequest创建irp    
　　　11.2.5 用ioallocateirp创建irp    
　　11.3 其他方法获得设备指针    
　　　11.3.1 用obreferenceobjectbyname获得设备指针    
　　　11.3.2 剖析iogetdeviceobjectpointer    
　　　11.4 小结    
　第12章 分层驱动程序    
　　本章主要介绍了分层驱动的概念。分层驱动可以将功能复杂的驱动程序分解为多个功能简单的驱动程序。多个分层的驱动程序形成一个设备堆栈，irp请求首先发送到设备堆栈的顶层，然后依次穿越每层的设备堆栈，最终完成irp请求。
　　12.1 分层驱动程序概念    
　　　12.1.1 分层驱动程序的概念    
　　　12.1.2 设备堆栈与挂载    
　　　12.1.3 i/o堆栈    
　　　12.1.4 向下转发irp    
　　　12.1.5 挂载设备对象示例    
　　　12.1.6 转发irp示例    
　　　12.1.7 分析    
　　　12.1.8 遍历设备栈    
　　12.2 完成例程    
　　　12.2.1 完成例程概念    
　　　12.2.2 传播pending位    
　　　12.2.3 完成例程返回status_success    
　　　12.2.4 完成例程返回status_more_processing_required    
　　12.3 将irp分解成多个irp    
　　　12.3.1 原理    
　　　12.3.2 准备底层驱动    
　　　12.3.3 读派遣函数    
　　　12.3.4 完成例程    
　　　12.3.5 分析    
　　12.4 wdm驱动程序架构    
　　　12.4.1 wdm与分层驱动程序    
　　　12.4.2 wdm的加载方式    
　　　12.4.3 功能设备对象    
　　　12.4.4 物理设备对象    
　　　12.4.5 物理设备对象与即插即用    
　　12.5 小结    
　第13章 让设备实现即插即用    
　本章首先介绍即插即用的概念和驱动程序支持即插即用功能的必要性。另外，本章还介绍如何利用wdm驱动程序开发框架设计支持即插即用功能的驱动程序。
　　13.1 即插即用概念    
　　　13.1.1 历史原因    
　　　13.1.2 即插即用的目标    
　　　13.1.3 windows中即插即用相关组件    
　　　13.1.4 遗留驱动程序    
　　13.2 即插即用irp    
　　　13.2.1 即插即用irp的功能代码    
　　　13.2.2 处理即插即用irp的派遣函数    
　　13.3 通过设备接口寻找设备    
　　　13.3.1 设备接口    
　　　13.3.2 wdm驱动中设置接口    
　　　13.3.3 应用程序寻找接口    
　　　13.3.4 查看接口设备    
　　13.4 启动和停止设备    
　　　13.4.1 为一个实际硬件安装hellowdm    
　　　13.4.2 启动设备    
　　　13.4.3 转发并等待    
　　　13.4.4 获得设备相关资源    
　　　13.4.5 枚举设备资源    
　　　13.4.6 停止设备    
　　13.5 即插即用的状态转换    
　　　13.5.1 状态转换图    
　　　13.5.2 irp_mn_query_stop_device    
　　　13.5.3 irp_mn_query_remove_device    
　　13.6 其他即插即用irp    
　　　13.6.1 irp_mn_filter_resource_requirements    
　　　13.6.2 irp_mn_query_capabilities    
　　13.7 小结    
　第14章 电源管理    
　本章主要介绍了如何在wdm驱动程序中进行电源处理。电源处理主要是处理好电源状态和设备状态。
　　14.1 wdm电源管理模型    
　　　14.1.1 概述    
　　　14.1.2 热插拔    
　　　14.1.3 电源状态    
　　　14.1.4 设备状态    
　　　14.1.5 状态转换    
　　14.2 处理irp_mj_power    
　　14.3 处理irp_mn_query_capabilities    
　　　14.3.1 device_capabilities    
　　　14.3.2 一个试验    
　　14.4 小结    
第3篇 实用篇
　第15章 i/o端口操作    
　本章总结了多种i/o端口操作的方法。这些方法本质上是一样的，都是将端口输入输出的汇编指令运行在内核模式中。
　　15.1 概述    
　　　15.1.1 从dos说起    
　　　15.1.2 汇编实现    
　　　15.1.3 ddk实现    
　　15.2 工具软件winio    
　　　15.2.1 winio简介    
　　　15.2.2 使用方法    
　　15.3 端口操作实现方法一    
　　　15.3.1 驱动端程序    
　　　15.3.2 应用程序端程序    
　　15.4 端口操作实现方法二    
　　　15.4.1 驱动端程序    
　　　15.4.2 应用程序端程序    
　　15.5 端口操作实现方法三    
　　　15.5.1 驱动端程序    
　　　15.5.2 应用程序端程序    
　　15.6 端口操作实现方法四    
　　　15.6.1 原理    
　　　15.6.2 驱动端程序    
　　　15.6.3 应用程序端程序    
　　15.7 驱动pc喇叭    
　　　15.7.1 可编程定时器    
　　　15.7.2 pc喇叭    
　　　15.7.3 操作代码    
　　15.8 操作并口设备    
　　　15.8.1 并口设备简介    
　　　15.8.2 并口寄存器    
　　　15.8.3 并口设备操作    
　　15.9 小结    
第16章 pci设备驱动    
本章主要介绍pci设备的驱动开发。首先介绍了pci总线协议。作为驱动程序员，开发pci驱动程序首先要了解pci配置空间。根据读取pci配置空间，可以得到pci设备的所有资源。另外，本章还总结了四种获取pci配置空间的方法。
　　16.1 pci总线协议    
　　　16.1.1 pci总线简介    
　　　16.1.2 pci配置空间简介    
　　16.2 访问pci配置空间方法一    
　　　16.2.1 两个重要寄存器    
　　　16.2.2 示例    
　　16.3 访问pci配置空间方法二    
　　　16.3.1 ddk函数读取配置空间    
　　　16.3.2 示例    
　　16.4 访问pci配置空间方法三    
　　　16.4.1 通过即插即用irp获得pci配置空间    
　　　16.4.2 示例    
　　16.5 访问pci配置空间方法四    
　　　16.5.1 创建irp_mn_read_config    
　　　16.5.2 示例    
　　16.6 pci设备驱动开发示例    
　　　16.6.1 开发步骤    
　　　16.6.2 中断操作    
　　　16.6.3 操作设备物理内存    
　　　16.6.4 示例    
　　16.7 小结    
第17章 usb设备驱动    
　本章首先介绍了usb总线协议的基本框架，其中包括usb总线的拓扑结构，usb通信的流程，还有usb的四种传输模式。另外，本章介绍了如何编写usb总线设备的驱动程序。
　　17.1 usb总线协议    
　　　17.1.1 usb设备简介    
　　　17.1.2 usb连接拓扑结构    
　　　17.1.3 usb通信的流程    
　　　17.1.4 usb四种传输模式    
　　17.2 windows下的usb驱动    
　　　17.2.1 观察usb设备的工具    
　　　17.2.2 usb设备请求    
　　　17.2.3 设备描述符    
　　　17.2.4 配置描述符    
　　　17.2.5 接口描述符    
　　　17.2.6 端点描述符    
　　17.3 usb驱动开发实例    
　　　17.3.1 功能驱动与物理总线驱动    
　　　17.3.2 构造usb请求包    
　　　17.3.3 发送usb请求包    
　　　17.3.4 usb设备初始化    
　　　17.3.5 usb设备的插拔    
　　　17.3.6 usb设备的读写    
　　17.4 小结    
　第18章 sdio设备驱动    
本章首先介绍了sdio协议，讲述了sd内存卡和sdio卡的兼容问题。然后介绍了sdio协议中的发送命令、回应命令、传送数据等相关协议。随后，本章又介绍了windows中，ddk提供的对sdio卡设备的支持。然后介绍了如何利用总线驱动，使sdio设备初始化，接收中断，发送和接收数据等操作。
　　18.1 sdio协议    
　　　18.1.1 sd内存卡概念    
　　　18.1.2 sdio卡概念    
　　　18.1.3 sdio总线    
　　　18.1.4 sdio令牌    
　　　18.1.5 sdio令牌格式    
　　　18.1.6 sdio的寄存器    
　　　18.1.7 cmd52命令    
　　　18.1.8 cmd53命令    
　　18.2 sdio卡驱动开发框架    
　　　18.2.1 sdio host controller驱动    
　　　18.2.2 sdio卡的初始化    
　　　18.2.3 中断回调函数    
　　　18.2.4 获得和设置属性    
　　　18.2.5 cmd52    
　　　18.2.6 cmd53    
　　18.3 sdio开发实例    
　　18.4 小结    
　第19章 虚拟串口设备驱动    
　本章介绍了串口开发的框架模型，在串口的adddevice例程中需要暴露出一个串口的符号连接，另外在相应的注册表中需要进行设置。在串口与应用程序的通信中，主要是一组ddk定义的io控制码，这些io控制码负责由应用程序向驱动发出请求。
　　19.1 串口简介    
　　19.2 ddk串口开发框架    
　　　19.2.1 串口驱动的入口函数    
　　　19.2.2 应用程序与串口驱动的通信    
　　　19.2.3 写的实现    
　　　19.2.4 读的实现    
　　19.3 小结    
　第20章 摄像头设备驱动程序    
　本章主要介绍了微软提供的摄像头驱动框架。在该框架中，微软提供了类驱动和小驱动的概念。对于驱动程序员的任务就是编写小驱动程序。
　　20.1 wdm摄像头驱动框架    
　　　20.1.1 类驱动与小驱动    
　　　20.1.2 摄像头的类驱动与小驱动    
　　　20.1.3 编写小驱动程序    
　　　20.1.4 小驱动的流控制    
　　20.2 虚拟摄像头开发实例    
　　　20.2.1 编译和安装    
　　　20.2.2 虚拟摄像头入口函数    
　　　20.2.3 对stream_request_block的处理函数    
　　　20.2.4 打开视频流    
　　　20.2.5 对视频流的读取    
　　20.3 小结    
第4篇 提高篇
　第21章 再论irp    
　本章将相关irp的操作做了进一步的总结。首先是转发irp，归纳了几种不同的方式。其次总结了创建irp的几种不同方法。创建irp总的来说分为创建同步irp和创建异步irp。对于创建同步irp，操作比较简单，i/o管理器会负责回收irp的相关内存，但是使用不够灵活。对于创建异步irp，操作比较复杂，程序员需要自己负责对irp及相关内存回收，但使用十分灵活。
　　21.1 转发irp    
　　　21.1.1 直接转发    
　　　21.1.2 转发并且等待    
　　　21.1.3 转发并且设置完成例程    
　　　21.1.4 暂时挂起当前irp    
　　　21.1.5 不转发irp    
　　21.2 创建irp    
　　　21.2.1 iobuilddeviceiocontrolrequest    
　　　21.2.2 创建有超时的ioctl irp    
　　　21.2.3 用iobuildsynchronousfsdrequest创建irp    
　　　21.2.4 关于iobuildasynchronousfsdrequest    
　　　21.2.5 关于ioallocateirp    
　　21.3 小结    
第22章 过滤驱动程序    
　本章主要介绍wdm和nt式过滤驱动程序开发。过滤驱动程序开发十分灵活，可以修改已有驱动程序的功能，也可以对数据进行过滤加密。另外，利用过滤驱动程序还能编写出很多具有相当功能强大的程序来。
　22.1 文件过滤驱动程序    
　　22.1.1 过滤驱动程序概念    
　　22.1.2 过滤驱动程序的入口函数    
　　22.1.3 u盘过滤驱动程序    
　　22.1.4 过滤驱动程序加载方法一    
　　22.1.5 过滤驱动程序加载方法二    
　　22.1.6 过滤驱动程序的adddevice例程    
　　22.1.7 磁盘命令过滤    
　22.2 nt式过滤驱动程序    
　　22.2.1 nt式过滤驱动程序    
　　22.2.2 nt过滤驱动的入口函数    
　　22.2.3 挂载过滤驱动    
　　22.2.4 过滤键盘读操作    
　22.3 小结    
　第23章 高级调试技巧    
　本章将介绍一些windows开发驱动的高级调试技巧。有一些高级驱动程序调试技巧，可以帮助程序员找出驱动程序中的bug。另外，利用一些第三方工具软件，也可以帮助程序员找到驱动程序中的漏洞，从而提高开发效率。
　23.1 一般性调试技巧    
　　23.1.1 打印调试信息    
　　23.1.2 存储dump信息    
　　23.1.3 使用windbg调试工具    
　23.2 高级内核调试技巧    
　　23.2.1 安装vmware    
　　23.2.2 在虚拟机上加载驱动程序    
　　23.2.3 vmware和windbg联合调试驱动程序    
　23.3 用irptrace调试驱动程序    
　23.4 小结